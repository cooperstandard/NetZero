// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: balances.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createBalance = `-- name: CreateBalance :one
INSERT INTO balances (user_id, group_id, creditor_id, updated_at, balance) 
  VALUES ($1, $2, $3, NOW(), $4)
RETURNING user_id, group_id, creditor_id, updated_at, balance
`

type CreateBalanceParams struct {
	UserID     uuid.NullUUID `json:"user_id"`
	GroupID    uuid.NullUUID `json:"group_id"`
	CreditorID uuid.NullUUID `json:"creditor_id"`
	Balance    string        `json:"balance"`
}

func (q *Queries) CreateBalance(ctx context.Context, arg CreateBalanceParams) (Balance, error) {
	row := q.db.QueryRowContext(ctx, createBalance,
		arg.UserID,
		arg.GroupID,
		arg.CreditorID,
		arg.Balance,
	)
	var i Balance
	err := row.Scan(
		&i.UserID,
		&i.GroupID,
		&i.CreditorID,
		&i.UpdatedAt,
		&i.Balance,
	)
	return i, err
}

const getBalanceForUserByGroup = `-- name: GetBalanceForUserByGroup :many
SELECT balances.updated_at, balances.balance, users.name, users.email
  FROM balances JOIN users ON users.id = creditor.id
WHERE balances.group_id = $1 and user_id = $2
`

type GetBalanceForUserByGroupParams struct {
	GroupID uuid.NullUUID `json:"group_id"`
	UserID  uuid.NullUUID `json:"user_id"`
}

type GetBalanceForUserByGroupRow struct {
	UpdatedAt time.Time      `json:"updated_at"`
	Balance   string         `json:"balance"`
	Name      sql.NullString `json:"name"`
	Email     string         `json:"email"`
}

func (q *Queries) GetBalanceForUserByGroup(ctx context.Context, arg GetBalanceForUserByGroupParams) ([]GetBalanceForUserByGroupRow, error) {
	rows, err := q.db.QueryContext(ctx, getBalanceForUserByGroup, arg.GroupID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBalanceForUserByGroupRow
	for rows.Next() {
		var i GetBalanceForUserByGroupRow
		if err := rows.Scan(
			&i.UpdatedAt,
			&i.Balance,
			&i.Name,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
