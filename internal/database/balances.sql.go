// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: balances.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createBalance = `-- name: CreateBalance :one
INSERT INTO balances (user_id, group_id, creditor_id, updated_at, balance) 
  VALUES ($1, $2, $3, NOW(), $4)
RETURNING user_id, group_id, creditor_id, updated_at, balance
`

type CreateBalanceParams struct {
	UserID     uuid.UUID `json:"user_id"`
	GroupID    uuid.UUID `json:"group_id"`
	CreditorID uuid.UUID `json:"creditor_id"`
	Balance    string    `json:"balance"`
}

func (q *Queries) CreateBalance(ctx context.Context, arg CreateBalanceParams) (Balance, error) {
	row := q.db.QueryRowContext(ctx, createBalance,
		arg.UserID,
		arg.GroupID,
		arg.CreditorID,
		arg.Balance,
	)
	var i Balance
	err := row.Scan(
		&i.UserID,
		&i.GroupID,
		&i.CreditorID,
		&i.UpdatedAt,
		&i.Balance,
	)
	return i, err
}

const getBalance = `-- name: GetBalance :one
SELECT user_id, group_id, creditor_id, updated_at, balance FROM balances
WHERE
  user_id = $1 AND group_id = $2 and creditor_id = $3
`

type GetBalanceParams struct {
	UserID     uuid.UUID `json:"user_id"`
	GroupID    uuid.UUID `json:"group_id"`
	CreditorID uuid.UUID `json:"creditor_id"`
}

func (q *Queries) GetBalance(ctx context.Context, arg GetBalanceParams) (Balance, error) {
	row := q.db.QueryRowContext(ctx, getBalance, arg.UserID, arg.GroupID, arg.CreditorID)
	var i Balance
	err := row.Scan(
		&i.UserID,
		&i.GroupID,
		&i.CreditorID,
		&i.UpdatedAt,
		&i.Balance,
	)
	return i, err
}

const getBalanceForCreditorByGroup = `-- name: GetBalanceForCreditorByGroup :many
SELECT balances.updated_at, balances.balance, users.name, users.email
  FROM balances JOIN users ON users.id = creditor.id
WHERE balances.group_id = $1 and creditor_id = $2
`

type GetBalanceForCreditorByGroupParams struct {
	GroupID    uuid.UUID `json:"group_id"`
	CreditorID uuid.UUID `json:"creditor_id"`
}

type GetBalanceForCreditorByGroupRow struct {
	UpdatedAt time.Time      `json:"updated_at"`
	Balance   string         `json:"balance"`
	Name      sql.NullString `json:"name"`
	Email     string         `json:"email"`
}

func (q *Queries) GetBalanceForCreditorByGroup(ctx context.Context, arg GetBalanceForCreditorByGroupParams) ([]GetBalanceForCreditorByGroupRow, error) {
	rows, err := q.db.QueryContext(ctx, getBalanceForCreditorByGroup, arg.GroupID, arg.CreditorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBalanceForCreditorByGroupRow
	for rows.Next() {
		var i GetBalanceForCreditorByGroupRow
		if err := rows.Scan(
			&i.UpdatedAt,
			&i.Balance,
			&i.Name,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBalanceForDebtorByGroup = `-- name: GetBalanceForDebtorByGroup :many
SELECT balances.updated_at, balances.balance, users.name, users.email
  FROM balances JOIN users ON users.id = creditor.id
WHERE balances.group_id = $1 and user_id = $2
`

type GetBalanceForDebtorByGroupParams struct {
	GroupID uuid.UUID `json:"group_id"`
	UserID  uuid.UUID `json:"user_id"`
}

type GetBalanceForDebtorByGroupRow struct {
	UpdatedAt time.Time      `json:"updated_at"`
	Balance   string         `json:"balance"`
	Name      sql.NullString `json:"name"`
	Email     string         `json:"email"`
}

func (q *Queries) GetBalanceForDebtorByGroup(ctx context.Context, arg GetBalanceForDebtorByGroupParams) ([]GetBalanceForDebtorByGroupRow, error) {
	rows, err := q.db.QueryContext(ctx, getBalanceForDebtorByGroup, arg.GroupID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBalanceForDebtorByGroupRow
	for rows.Next() {
		var i GetBalanceForDebtorByGroupRow
		if err := rows.Scan(
			&i.UpdatedAt,
			&i.Balance,
			&i.Name,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertOrUpdateBalance = `-- name: InsertOrUpdateBalance :one
INSERT INTO balances (user_id, group_id, creditor_id, updated_at, balance) VALUES ($1, $2, $3, NOW(), $4)
ON CONFLICT (user_id, group_id, creditor_id) DO UPDATE SET balance = balance + $4, updated_at = NOW()
RETURNING user_id, group_id, creditor_id, updated_at, balance
`

type InsertOrUpdateBalanceParams struct {
	UserID     uuid.UUID `json:"user_id"`
	GroupID    uuid.UUID `json:"group_id"`
	CreditorID uuid.UUID `json:"creditor_id"`
	Balance    string    `json:"balance"`
}

func (q *Queries) InsertOrUpdateBalance(ctx context.Context, arg InsertOrUpdateBalanceParams) (Balance, error) {
	row := q.db.QueryRowContext(ctx, insertOrUpdateBalance,
		arg.UserID,
		arg.GroupID,
		arg.CreditorID,
		arg.Balance,
	)
	var i Balance
	err := row.Scan(
		&i.UserID,
		&i.GroupID,
		&i.CreditorID,
		&i.UpdatedAt,
		&i.Balance,
	)
	return i, err
}

const updateBalance = `-- name: UpdateBalance :one
UPDATE
  balances
SET
  balance = $1, updated_at = NOW()
WHERE
  user_id = $2 AND group_id = $3 and creditor_id = $4
RETURNING user_id, group_id, creditor_id, updated_at, balance
`

type UpdateBalanceParams struct {
	Balance    string    `json:"balance"`
	UserID     uuid.UUID `json:"user_id"`
	GroupID    uuid.UUID `json:"group_id"`
	CreditorID uuid.UUID `json:"creditor_id"`
}

func (q *Queries) UpdateBalance(ctx context.Context, arg UpdateBalanceParams) (Balance, error) {
	row := q.db.QueryRowContext(ctx, updateBalance,
		arg.Balance,
		arg.UserID,
		arg.GroupID,
		arg.CreditorID,
	)
	var i Balance
	err := row.Scan(
		&i.UserID,
		&i.GroupID,
		&i.CreditorID,
		&i.UpdatedAt,
		&i.Balance,
	)
	return i, err
}
